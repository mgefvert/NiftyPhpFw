<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
        <title>Get Started with Nifty Framework</title>
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
        <h1>9. Persistence</h1>

        <p>In the previous chapter, you read about how Nifty can access databases through wrapping the PDO
            layer of PHP in NF_DB and NF_IDatabase.</p>
        <p>Another, and more elegant way, of using database access, is to forego the use of SQL and
            queries altogether, and map PHP classes straight to the database tables. This is achieved through
            a process called Persistence - the ability to persist objects to and from the database.</p>
        <p>The process used in Nifty does not rely on ActiveRecords, used in many other frameworks, but
            is a custom implementation of a "Plain Old PHP Objects" approach. This means that your classes
            does not need to descend from any system base classes, all you need is a simple statement
            to match the class to a table.</p>
            
        <h2>9.1 An example</h2>
        <p>Suppose you have a table called 'users' in the database that looks like this:</p>
        <table>
            <tr>
                <th>uid</th>
                <th>usertype</th>
                <th>username</th>
                <th>email</th>
                <th>phone</th>
            </tr>
            <tr>
                <td>32</td>
                <td>2</td>
                <td>Betty</td>
                <td>betty@example.com</td>
                <td>555-1234</td>
            </tr>
            <tr>
                <td>33</td>
                <td>1</td>
                <td>Chris</td>
                <td>chris@example.com</td>
                <td>555-5678</td>
            </tr>
            <tr>
                <td>34</td>
                <td>2</td>
                <td>Richard</td>
                <td>richard@example.com</td>
                <td>555-9876</td>
            </tr>
        </table>
        <p>Wouldn't it be nice if you create create a class as follows and just map it onto the
            table? With just one little mapping row, this all becomes possible.</p>
        <code>&lt;?php

NF_Persistence::mapTable('Data_User', 'users', 'uid');
        
class Data_User
{
    public $uid;
    public $usertype;
    public $username;
    public $email;
    public $phone;
}</code>
        <p>What does this do? Well, <tt>NF_Persistence</tt> is a subsystem that uses the database classes in Nifty to load
            and save objects directly to database, without having to write SQL queries. When working with the default database
            it is available as the global variable <tt>$Persistence</tt>; however, if we're working with other databases, you
            can easily wrap persistence functionality around those too by running <tt>$p = new NF_Persistence(DB::connect('test'));</tt>,
            and a new Persistence object will be instantiated working on that database instead.</tt>
        <p>The <tt>mapTable</tt> call on NF_Persistence informs us that the class "Data_User" is mapped to the database table "users",
            and that the primary key used to identify each object is "uid". This is all that Nifty needs to start loading and saving
            objects.</p>
        <p>Now we are ready to do some fun.</p>
        <code>// Load user Betty from the database
$user = $Persistence->load('Data_User', 32);
print_r($user);</code>
        <p>...loads the user Betty from the database and outputs all her data in the browser. <tt>$user</tt> is now a Data_User object that
            contains all the data from record 32 of the table above.</p>
        <p>But let's not stop there. We can also manipulate data and save it back:</p>
        <code>// Load Betty from the database and change her phone number to 555-9997
$user = $Persistence->load('Data_User', 32);
$user->phone = '555-9997';
$Persistence->save($user);</code>
        <p>The <tt>save()</tt> method assumes that we're operating on an existing object in the database, and issues an SQL statement
            on the form <tt>UPDATE users SET... WHERE uid=32</tt>, causing all of Betty's data to be written back to the table. It refuses
            to work if the primary key field isn't set to a value.</p>
        <p>But, also, creating a new user takes very little effort:</p>
        <code>$user = new Data_User();
$user->name = 'John';
$user->usertype = 1;
$user->email = 'john@example.com';
$user->phone = 'unlisted';
$Persistence->insert($user);</code>
        <p><tt>insert()</tt> inserts a new object as a new record in the table, by issuing the proper <tt>INSERT INTO</tt> statement.
            If the primary key is an automatically incrementing field, it will return the ID assigned to the new record by the database.
            It will not, however, update the object. There is also a <tt>replace()</tt> call that issues a <tt>REPLACE INTO</tt> statement.</p>
        
        <h2>9.3 The NF_Persistence class</h2>
        <table class="info">
            <tr>
                <th colspan="2">NF_Persistence methods</th>
            </tr>
            <tr>
                <td><tt>new NF_Persistence($db)</tt></td>
                <td>Creates a new NF_Persistence object wrapping a particular database. <tt>$Persistence</tt> always wraps the default database,
                    so you never need to instantiate that one. Table and field mapping calls always take place on NF_Persistence directly.</td>
            </tr>
            <tr>
                <td><tt>mapTable($class, $table, $keyfield)</tt></td>
                <td>Maps a data class onto a table using the specified field as the primary key. $keyfield can be an array of fields if there
                    are multiple fields in the primary key.</td>
            </tr>
            <tr>
                <td><tt>mapFields($class, $fieldmap)</tt></td>
                <td>Maps the properties of a data class onto table field names using an associative array, on the form <tt>'property' => 'field name'</tt>.</td>
            </tr>
            <tr>
                <td><tt>mapRelation1M(...)</tt></td>
                <td>Maps a one-to-many relation between to data classes. Explained further below.</td>
            </tr>
            <tr>
                <td><tt>mapRelationM1(...)</tt></td>
                <td>Maps a many-to-one relation between to data classes.</td>
            </tr>
            <tr>
                <td><tt>mapRelationMM(...)</tt></td>
                <td>Maps a many-to-many relation between to data classes.</td>
            </tr>
        </table>
        
        <h2>9.4 The $Persistence object, and any other NF_Persistence objects instantiated</h2>
        <p>As already mentioned, <tt>$Persistence</tt> is always available and always instantiated already, wrapping the default database
            available through <tt>DB::connect()</tt>. It, and any other persistence objects you may have created for other databases, have
            the following methods:</p>
        <table class="info">
            <tr>
                <th colspan="2">$Persistence object loading methods</th>
            </tr>
            <tr>
                <td><tt>tryLoad($class, $id)</tt></td>
                <td>Tries to load a specific object from the table, identified by <tt>$id</tt>. If the table requires multiple values to identify an object,
                    $id will be an array of values. If the object cannot be located, it will return <tt>false</tt>.</td>
            </tr>
            <tr>
                <td><tt>load($class, $id)</tt></td>
                <td>Does the same job as tryLoad(), but throws an exception of type <tt>NF_EDatabaseError</tt> if the object cannot be loaded.</td>
            </tr>
            <tr>
                <td><tt>loadAll($class)</tt></td>
                <td>Loads all objects from the table in primary key order.</td>
            </tr>
            <tr>
                <td><tt>loadByFields($class, $values)</tt></td>
                <td>Loads object from a table given by the values in the associative $values array, consisting of a number of <tt>field => value</tt>
                    definitions.</td>
            </tr>
            <tr>
                <td><tt>loadByWhereClause($class, $where)</tt></td>
                <td>Loads objects from a table given by the $where SQL clause, which must start by 'WHERE...'. All values in the SQL clause must
                    of course be properly escaped. It's possible to use other SQL clauses in the $where clause as well, for instance 'ORDER BY' or similar -\
                    the clause is simply appended to the SQL query.</td>
            </tr>
            <tr>
                <td><tt>loadByQuery($class, $id)</tt></td>
                <td>Does the same thing as loadByWhereClause(), but allows you to manually craft the entire SQL query. This can be useful if you
                    want to write joins, include calculated fields, etc. Take care to name the fields properly, because they will end up in the
                    object with the field name you gave them in the query. (Field mapping described below does apply.)</td>
            </tr>
            <tr>
                <th colspan="2">$Persistence data manipulation methods</th>
            </tr>
            <tr>
                <td><tt>insert($object)</tt></td>
                <td>Insert a new object into the database table. Returns the newly generated record ID, if available.</td>
            </tr>
            <tr>
                <td><tt>replace($object)</tt></td>
                <td>Performs the same way as insert(), but optionally replaces any earlier record identified by the same primary key. Relies on the
                    MySQL extension "REPLACE INTO", which might not be available for other databases.</td>
            </tr>
            <tr>
                <td><tt>save($object)</tt></td>
                <td>Saves the fields of an object back to the database table, assuming that the record already exists and can be identified by the
                    primary key property.</td>
            </tr>
            <tr>
                <td><tt>deleteObject($object)</tt></td>
                <td>Deletes the object from the database. it assumes that the record exists in the table and is identified by the primary key property
                    of the object.</td>
            </tr>
            <tr>
                <td><tt>delete($class, $id)</tt></td>
                <td>Deletes a row from the database table - identical to deleteObject(), but doesn't require an already instantated object; it works
                    directly on the class and id specified as parameter.</td>
            </tr>
            <tr>
                <td><tt>save($object)</tt></td>
                <td>Saves the fields of an object back to the database table, assuming that the record already exists and can be identified by thei
                    primary key property.</td>
            </tr>
            <tr>
                <th colspan="2">$Persistence SQL query rewriting methods</th>
            </tr>
            <tr>
                <td><tt>sql($class, $query)</tt></td>
                <td>Translates an SQL query using alternative SQL syntax described below, to operate on classes.</td>
            </tr>
        </table>

        <h2>9.3 Mapping tables</h2>
        <p>For every class you create, you'll have to map the class onto a record.</p>
        <code>NF_Persistence::mapTable('Data_User', 'users', 'uid');</code>
        <p>The proper way of doing this is, as we saw before, in the beginning of the data class file. Since the autoloader in Nifty
            will automatically load the class when it's needed, it will also automatically issue the mapping statements that maps
            the class to the table.</p>
        <p>mapTable, in this case, tells the persistence layer to map the <tt>Data_User</tt> class onto the table <tt>users</tt>.
            The <tt>uid</tt> property of the class is the property that holds the unique key and allows Nifty to load and save objects
            uniquely. If we have a multiple primary key consisting of several fields, we would have written it differently:</p>
        <code>NF_Persistence::mapTable('Data_Invoice', 'invoices', array('company', 'id'));</code>
        <p>This assumes that the primary key is made up of the fields "company" and "id"; and now it's possible to load an object from
            that table by running the call</p>
        <code>$invoice = $Persistence->load('Data_Invoice', array(1, 42));</code>
        <p>Note that, as will be explained below, if the actual field names differ from the object property names, it's always the object
            property that is given in the primary key definition.</p>
        
        <h2>9.4 Mapping fields</h2>
        <p>If you have legacy tables with cryptic field names, or the table you're using have
            prefixes on the field names, or if you for any other reason want to change the
            names of the variables in the mapped data classes, you can do so. Nifty provides you
            with a capability to customize the field mapping.</p>
        <p>A somewhat common practice is to prefix field names with a short table identifier. Since we like to avoid this on objects,
            Nifty provides us with a means to override that sort of behavior by mapping the properties of the class onto field names.</p>
        <code>&lt;?php

NF_Persistence::mapTable('Data_User', 'användare', 'uid');
NF_Persistence::mapFields('Data_User', array(
    'uid'   => 'u_uid',
    'type'  => 'u_user_type',
    'name'  => 'u_user_name',
    'email' => 'u_email_address',
    'phone' => 'u_phone_number'
));
        
class Data_User
{
    public $uid;
    public $type;
    public $name;
    public $email;
    public $phone;
}</code>
        <p>This mapping statement, <tt>mapFields()</tt>, tells Nifty to automatically translate the field names when it loads the record
            from the database table into the given properties of the class. If the database schema is inaptly named, or prefixed or otherwise
            with a clumsy field naming system, this can significantly ease the coding process. It also provides for renaming fields in the
            table without having to necessarily update the code in more than one place.</p>
        <p>We are now ready to use the object without refering to the fields of the table - all we need are the properties of the class. 
            Note, specifically, that the <tt>mapTable</tt> call doesn't even use the "u_uid" field name - it only uses the property "uid".</p>
        
        <h2>9.5 Alternative SQL syntax</h2>
        <p>Mapping fields means that our SQL queries get a little bit more difficult to write, since we're not operating on field names anymore,
            but properties of objects. To help with this, the persistence layer provides a way to escape our properties and translate them
            automatically into field names. So, instead of</p>
        <code>select * from users where u_user_type=1 order by u_user_name</code>
        <p>We write</p>
        <code>select * from [:DataUser] where [type]=1 order by [name]</code>
        <p>The syntax is as follows:</p>
        <table class="info">
            <tr>
                <th colspan="2">Alternative SQL field syntax</th>
            </tr>
            <tr>
                <td><tt>[variable]</tt></td>
                <td>Inserts the field name for <tt>variable</tt> from the current class (the class name given to <tt>$Persistence</tt>)</td>
            </tr>
            <tr>
                <td><tt>[variable:class]</tt></td>
                <td>Inserts the fully qualified <tt>table.field</tt> from the given class (either our own
                    class or another mapped class)</td>
            </tr>
            <tr>
                <td><tt>[:class]</tt></td>
                <td>Insert the table name for the given class (either our own or another)</td>
            </tr>
        </table>
        <p>A more complex example might state the following:</p>
        <code>$users = $Persistence->loadByQuery('Data_User', '
    select [:Data_User].*, [description:Data_UserType] as description
    from [:Data_User],
        left join [:Data_UserType] on [type] = [id:Data_UserType]
    order by [name]
');</code>
        <p>

        <p>All of the variables and classes are now translated nicely into fields and tables.
            Notice also that we now provide a column alias for the 'description' field - this is
            because most certainly the field in the result set won't be called 'description' any
            longer, but something silly like 'beskrivning', and we don't want that in our dynamic
            object data.</p>
        <p>There is yet no way to express table aliases with this syntax.</p>
        
        <h3>8.2.4 Using extra or joined field data outside of the table</h3>
        <p>By default, all of the fields that are declared in the class, must map onto some kind
            of field, otherwise persisting methods may fail. However, PHP provides us with a way
            to go around this behavior.</p>
        <p>PHP allows us to store extra data apart from the already defined fields. If I use the
            Data_User class above, and perform <tt>$user->hobbies = 'Knitting'</tt>, this information
            will be stored in a dynamic field outside of the normally declared properties of the
            object. This information is regarded as extra data by <tt>$Persistence</tt>, and will not be saved.</p>
        <p>This means that we can store calculated data inside the object that does not affect
            persistence. Of course, these objects are meant to strictly contain data, not to be
            used for much else; if you need to do complex tasks with it, it is better to provide
            helper classes and aggregation to do this, maintaining a clean and efficient design
            on the data-mapped classes.</p>
        <p>Sometimes, it may be difficult to load all the information you want in a single step.
            Usually, there are a number of lookup tables which we need to access, to provide
            meaningful data to the end user. In this case, we may want to provide an explanation
            for the "usertype" field, which links to another table, usertypes.</p>
       <p>Using PHP's dynamic fields in conjunction with for instance the <tt>loadByQuery()</tt> method, we can
            easily accomplish this:</p>
        <code>$users = $Persistence->loadByQuery('Data_User', '
    select users.*, usertypes.description
    from users,
        left join usertypes on users.usertype = usertypes.id
    order by username
');</code>
        <p>When the persistence layer instantiates the objects from the data, it will happily
            insert also the description data field into the object, even though no such variable
            exists. PHP will create a dynamic field for this on the fly; this will be available
            to us as <tt>$user->description</tt>, but it will not be considered as persisted data, and
            will not be written back to the table.</p>
        <p class="security">Although the Persistence layer always escapes user data correctly
            before submitting queries (you don't need to worry about the text in the objects), 
            it does not take into account custom SQL query text that you write yourself. As 
            before, always use <tt>$db->escape()</tt> to escape any possible unsafe data.</p>
        
        <h3>8.2.5 Mapping relations between tables</h3>
        <p>There is another method of linking tables and objects together, and that is by using
            relation mapping. Using a few mapping calls, you can easily join data from several
            tables.</p>
        <p>Assume that we have two tables.</p>
        <table style="float: left; margin-right: 20px">
            <tr>
                <th colspan="5">Table <tt>users</tt> (<tt>Data_User</tt>)</th>
            </tr>
            <tr>
                <th>uid</th>
                <th>usertype</th>
                <th>username</th>
                <th>email</th>
                <th>phone</th>
            </tr>
            <tr>
                <td>32</td>
                <td>2</td>
                <td>Betty</td>
                <td>betty@example.com</td>
                <td>555-1234</td>
            </tr>
            <tr>
                <td>33</td>
                <td>1</td>
                <td>Chris</td>
                <td>chris@example.com</td>
                <td>555-5678</td>
            </tr>
            <tr>
                <td>34</td>
                <td>2</td>
                <td>Richard</td>
                <td>richard@example.com</td>
                <td>555-9876</td>
            </tr>
        </table>
        <table>
            <tr>
                <th colspan="5">Table <tt>usertypes</tt> (<tt>Data_UserType</tt>)</th>
            </tr>
            <tr>
                <th>id</th>
                <th>description</th>
                <th>admin</th>
            </tr>
            <tr>
                <td>1</td>
                <td>Administrator</td>
                <td>true</td>
            </tr>
            <tr>
                <td>2</td>
                <td>Normal user</td>
                <td>false</td>
            </tr>
        </table>
        <div style="clear: both"></div>
        <p>We can easily map these together by placing the following line in <tt>Data_User.php</tt>.</p>
        <code>NF_Persistence::mapRelationM1('Data_User', 'Data_UserType', 'usertype', 'id', 'objUserType');</code>
        <p>This tells the persistence layer that we have a Many-To-One relationship between the data
            in <tt>users</tt> and <tt>usertypes</tt> (one usertype can have many users). It is now possible
            to load all the data required through the following call.</p>
        <code>$users = $Persistence->loadAll('Data_User');
$usertypes = $Persistence->loadRelated($users, 'objUserType');</code>
        <p>The system will analyze <tt>$users</tt>, discover that it is an array of <tt>Data_User</tt>, examine
            the relationship given (<tt>objUserType</tt>) and discover that there is a mapping between these
            two classes. It will then proceed to load all relevant data from the <tt>usertypes</tt> table,
            form an array (<tt>$usertypes</tt>) from this, and also link the relevant objects to the
            original users as <tt>$users[0]->objUserType</tt>, <tt>$users[1]->objUserType</tt> etc.
            Keeping the variable <tt>$usertypes</tt> is strictly not required, but may be useful
            if you want to load additional data related to <tt>Data_UserType</tt>.</p>
        <p><tt>$Persistence</tt> also takes care to optimize the loaded information - usertype 1 and 2 will
            only be loaded once in this call; not one for each record in <tt>$users</tt>, so it is an efficient
            way of loading data.</p>
        <h3>8.2.6 Summary of the $Persistence object</h3>
        <p>The global <tt>$Persistence</tt> object is always wrapped around the default database, <tt>NF_DB::connect()</tt>.
            If you need to persist data to and from other databases, it is easy to create additional such
            persistence layers through <tt>$OtherDbPersistence = new NF_Persistence('otherdb');</tt></p>
        <p>If the primary key consists of multiple values, then pass an array with the appropriate values in <tt>$id</tt>.</p>
        <table>
            <tr>
                <th>Method</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><tt>__construct($dbname)</tt></td>
                <td>Create a new instance of <tt>NF_Persistence</tt> wrapped around another database than
                    the default database.</td>
            </tr>
            <tr>
                <td><tt>tryLoad($class, $id)</tt></td>
                <td>Try to instantiate a specific object from the database, optionally using the
                    database $db (otherwise use the default database through NF_DB::connect()). If
                    it cannot be found, return null. If you have multiple key values in the primary
                    key, use an array to specify the values.</td>
            </tr>
            <tr>
                <td><tt>load($class, $id)</tt></td>
                <td>Instantiate an object from the database. If it cannot be found, throw an
                    NF_EDatabaseError.</td>
            </tr>
            <tr>
                <td><tt>loadAll($class)</tt></td>
                <td>Load all objects from the specific table, in index order. Returns an array of
                    objects.</td>
            </tr>
            <tr>
                <td><tt>loadByFields($class, array $fieldValues)</tt></td>
                <td>Load a specific set of objects from the table. <tt>$fieldValues</tt> is an array with <tt>fieldname => value</tt>
                    items.</td>
            </tr>
            <tr>
                <td><tt>loadByWhereClause($class, $where)</tt></td>
                <td>Load a number of objects by a specified where clause. The clause must begin with
                    "where ...", and then the normal SQL field data. You may also use "order by"
                    in the query to order the result differently (even omitting where altogheter).</td>
            </tr>
            <tr>
                <td><tt>loadByQuery($class, $query)</tt></td>
                <td>Allows complete customization of the SQL query.</td>
            </tr>
            <tr>
                <td><tt>loadRelated(array $objects, $relation)</tt></td>
                <td>Loads the related objects identified by <tt>$relation</tt> and ties these into the <tt>$objects</tt> array.
                    Also returns an array with the complete set of loaded objects.</td>
            </tr>
            <tr>
                <td><tt>insert($obj)</tt></td>
                <td>Insert a new object as a new row into the database. Will generate and return
                    a new primary key id if necessary.</td>
            </tr>
            <tr>
                <td><tt>replace($obj)</tt></td>
                <td>MySQL-specific syntax: Uses a REPLACE INTO instead of an INSERT INTO.</td>
            </tr>
            <tr>
                <td><tt>save($obj)</tt></td>
                <td>Saves an already existing object back to the database.</td>
            </tr>
            <tr>
                <td><tt>deleteObject($obj)</tt></td>
                <td>Deletes an instantiated object from the database.</td>
            </tr>
            <tr>
                <td><tt>delete($class, $id)</tt></td>
                <td>Deletes an object from the database.</td>
            </tr>
        </table>

        <h3>8.2.7 Summary of NF_Persistence mapping calls</h3>
        <p>This is a summary of the available mapping calls to map classes to tables, fields and other tables.
            They always operate on the class <tt>NF_Persistence</tt>, never the global <tt>$Persistence</tt>.</p>
        <table>
            <tr>
                <th>Method</th>
                <th>Description</th>
            </tr>
            <tr>
                <td><tt>mapTable($class, $table, $key)</tt></td>
                <td>Maps a specific <tt>$class</tt> onto a table <tt>$table</tt>, using <tt>$key</tt> as the primary key.
                    If there are more than one field in the primary key, you may use <tt>array($key1, $key2...)</tt>
                    as the <tt>$key</tt>. The key given always refers to the object property, not the field name.</td>
            </tr>
            <tr>
                <td><tt>mapFields($class, array $fieldmap)</tt></td>
                <td>If you want to map object properties onto fields with different naming, use
                    this function. This can be if the database uses table prefixes, or if you
                    have legacy tables with undesired or cryptic field names. See "Mapping fields" 
                    for more information.</td>
            </tr>
            <tr>
                <td><tt>mapRelation1M($srcClass, $tgtClass,<br>&nbsp;&nbsp;$srcField, $tgtField, $objField)</tt></td>
                <td>Maps a One-To-Many relationship between <tt>$srcClass</tt> and <tt>$tgtClass</tt> 
                    using the fields <tt>$srcField</tt> and <tt>$tgtField</tt>. One to many means that there
                    may be multiple objects loaded for each source object. <tt>$objField</tt> will therefore be 
                    an <i>array of objects</i>.</td>
            </tr>
            <tr>
                <td><tt>mapRelationM1($srcClass, $tgtClass,<br>&nbsp;&nbsp;$srcField, $tgtField, $objField)</tt></td>
                <td>Maps a Many-To-One relationship between <tt>$srcClass</tt> and <tt>$tgtClass</tt> 
                    using the fields <tt>$srcField</tt> and <tt>$tgtField</tt>. Many to one means that there
                    may only be one single object loaded for each source object. <tt>$objField</tt> will therefore be 
                    a <i>single object</i> and not an array.</td>
            </tr>
            <tr>
                <td><tt>mapRelationMM($srcClass, $tgtClass,<br>&nbsp;&nbsp;$srcField, $tgtField, $objField,<br>&nbsp;&nbsp;$relClass, $relSrcField, $relTgtField)</tt></td>
                <td>Maps a Many-To-Many relationship between <tt>$srcClass</tt> and <tt>$tgtClass</tt> 
                    using the fields <tt>$srcField</tt> and <tt>$tgtField</tt>, which maps onto a relationship class <tt>$relClass</tt>, and
                    the fields <tt>$relSrcField</tt> and <tt>$relTgtField</tt>, respectively. Many to many means that there
                    may be multiple connections between all objects in the source and target tables, and for this reason,
                    a relationship table must be used to identify these relationships. The links can be expressed as<br>
                    <br>
                    <tt>$srcClass->srcField</tt> -> <tt>$relClass->relSrcField</tt> -> <tt>$relClass->relTgtField</tt> -> <tt>$tgtClass->tgtField</tt><br>
                    <br>
                    <tt>$objField</tt> will be an <i>array of objects</i>.</td>
            </tr>
        </table>
        
    </body>
</html>
