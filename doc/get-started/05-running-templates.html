<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
        <title>Get Started with Nifty Framework</title>
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
        <h1>5. Running templates</h1>
        <p>The strength of the Model-View-Controller pattern is in its clean separation of data,
            code and layout. As with many other frameworks, Nifty provides an MVC pattern
            to its workflow.</p>
        <p>Since, as we've seen, Pages are the controller classes that get instantiated depending
            on the URL and parameters that are sent in to the application, they are usually also
            responsible for digging out the data and processing whatever needs to be done.</p>
        <p>However, we don't want much (or any at all!) HTML in the actual page classes. This is
            left to templates. Nifty does not use a specific templating engine like Smarty or similar; 
            since PHP itself is an extremely capable templating engine, we simply use PHP itself 
            to provide the template parsing. This is done through the <tt>NF_Template</tt> class.</p>
        
        <h2>5.1 The NF_Template class and its runDefault() method</h2>
        <p>The <tt>NF_Template</tt> class is a class that loads a specific template file and processes it.
            All templates reside in the <tt>/app/templates</tt> folder; and since there usually are a lot of templates,
            they are organized in pretty much the same as the pages are organized, with a few small distinctions:</p>
        <ul>
            <li>The template folders aren't PascalCased, they retain the original url-cased structure.</li>
            <li>Each level in the page folder structure is represented as a folder in the template structure. Therefore,
                the page <tt>Customer</tt> has a folder for itself called <tt>/app/templates/customer</tt>, and the page
                <tt>Inventory_Parts</tt> has a folder called <tt>/app/templates/inventory/parts</tt>.</li>
            <li>Each method has it's own default template. <tt>executeView()</tt> corresponds to the <tt>view.phtml</tt> file,
                and the call <tt>http://host/customer/edit/3</tt> loads the <tt>/app/templates/customer/edit.phtml</tt> file.</li>
        </ul>
        <p>Since there is a handy static call inside <tt>NF_Template</tt>, instantiating a particular template 
            couldn't be easier. This might be a particular page, loading an object or two from the
            database upon request:</p>
        <code>&lt;?php
        
class Test extends NF_Page
{
    public function executeView()
    {
        global $Response;
        
        $data = NF_DB::connect()->queryAsObjects('select user, email from users');
        
        $Response->content = NF_Template::runDefault(null, array(
            'data' => $data
         ));
    }
}</code>
        <p>(<tt>null</tt> in the <tt>runDefault()</tt> call means "load the default file for this method"; we could have given another file too,
            like <tt>"table.phtml"</tt>. <tt>runDefault()</tt> would still have looked in the <tt>/app/templates/test/</tt> folder for it.</p>
        <p>And this might be our template, <tt>/app/templates/test/view.phtml</tt>:</p>
        <code>&lt;p&gt;These are users and their email addresses from the system:&lt;/p&gt;
&lt;? foreach($this-&gt;data as $x): ?&gt;
    &lt;p&gt;User &lt;?= html($x-&gt;user) ?&gt;, email &lt;?= html($x-&gt;email) ?&gt;&lt;/p&gt;
&lt;? endforeach ?&gt;</code>
        <p>Template files, as you can see, are complete PHP scripts. It is customary to give them the
            .phtml ending, to separate them from .php and .html files.</p>
        <p>What <tt>NF_Template::run()</tt> or <tt>NF_Template::runDefault()</tt> does, is that it creates a new 
            <tt>NF_Template</tt> class, wrapped around the file <tt>/app/templates/test/view.phtml</tt>, and pushes all 
            the data given in the array into the template. <tt>$this</tt> in the template is a pointer to 
            the <tt>NF_Template</tt> object we created; this means that the entire array we supply is 
            available through <tt>$this->data</tt>.</p>
        <p>Inside the template, we then create a for loop that iterates through <tt>$this->data</tt>, and
            prints it out to the user. Of course, shoule we wish, templates can be wrapped: It is not 
            impossible to call a template from within a template, if you need to.</p>
        <p class="security">Please note that we always escape the data through html() for safety.</p>
            
        <h2>5.2 Some other things you can do in templates</h2>
        <p>Since templates are just PHP files, there is no limit to what you can do with templates.
            Common features include looping through data, creating <tt>if()</tt> clauses to select different
            output depending on data, and calling on other helper classes to generate HTML output.</p>
        <p>There are also a few more special things you can do, which is built into Nifty and
            the templating classes.</p>
        
        <h3>5.2.1 Accessing variables</h3>
        <p>As previously, mentioned, you can always reach the data given to the template by using
            <tt>$this</tt>. This is the preferred way, since you can process it and also use
            the <tt>html()</tt> function to escape it properly.</p>
        <p>If you're combining templates, such as designing the master template, sometimes it's easier
            to see if you use an alternative form: Instead of writing <tt>&lt;?= $this->content &gt;</tt>, you can
            write <tt>&lt;@content&gt;</tt>. This is the exact same thing.</p>
        
        <h3>5.2.2 Translating</h3>
        <p>The normal way in Nifty to provide translation in the PHP code is to use the <tt>_t()</tt> function.
            This works well with templates too, but can become cumbersome. Take a look at this example:</p>
        <code>&lt;p&gt;&lt;?= _t('This is a headline') ?&gt;&lt;/p&gt;</code>
        <p>It's much easier to use the short form [@text]:</p>
        <code>&lt;p&gt;[@This is a headline]&lt;/p&gt;</code>
        <p>This will, in the same way as <tt>_t()</tt>, run the given text through the i18n (internationalization)
            engine and translate it, if necessary, according to the language texts provided - but it looks much
            cleaner.</p>
        
        <h2>5.3 A look at the NF_Template class</h2>
        
        <p>These are some of the common methods and properties of the <tt>NF_Template</tt> class.</p>
        
        <table>
            <tr>
                <th colspan="2">The NF_Template class</th>
            </tr>
            <tr>
                <td><tt>constructor($filename)</tt></td>
                <td>Create a new class through <tt>$tmpl = new NF_Template('filename');</tt></td>
            </tr>
            <tr>
                <td><i>variable</i></td>
                <td>Assign data directly to the template. I.e., to set the "data" variable to "hello, world",
                    write: <tt>$tmpl->data = "hello, world";</tt></td>
            </tr>
            <tr>
                <td><tt>clear()</tt></td>
                <td>Reset all the data supplied, but keep the template. This means that you
                    can run a template file several times with different data.</td>
            </tr>
            <tr>
                <td><tt>parse()</tt></td>
                <td>Parse the template using the supplied data, returning a string with the HTML produced.</td>
            </tr>
            <tr>
                <td><tt>::load($filename, array $data)</tt></td>
                <td>Load a template into a newly constructed class and assign data to it. This
                    returns an <tt>NF_Template</tt> object, ready to go. <tt>$filename</tt> should contain a path as 
                    well as a file name.</td>
            </tr>
            <tr>
                <td><tt>::loadDefault($filename, array $data)</tt></td>
                <td>Same as <tt>load()</tt>, but it matches the current page to the directory layout in the
                    /app/templates folder. If we provide a <tt>$filename</tt>, it will be loaded instead of the 
                    normal template for the method call. Leave <tt>$filename</tt> blank or null to select the default file.</td>
            </tr>
            <tr>
                <td><tt>::run($filename, array $data)</tt></td>
                <td>Like ::load(), but also parses the template and discards the object, leaving
                    you with only the resulting HTML string.</td>
            </tr>
            <tr>
                <td><tt>::runDefault($filename, array $data)</tt></td>
                <td>Like ::loadDefault(), but also parses the template and discards the object, leaving
                    you with only the resulting HTML string.</td>
            </tr>
        </table>
        
    </body>
</html>
