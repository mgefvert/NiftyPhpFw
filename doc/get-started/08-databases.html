<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
        <title>Get Started with Nifty Framework</title>
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
        <h1>8. Databases</h1>
        <p>The database layer in Nifty is rather capable, and provides a number of methods
            to connect and query databases.</p>
        
        <h2>8.1 Using NF_DB and NF_DB::connect()</h2>
        <p>NF_DB is the main access point for database calls. NF_DB maintains a list of database objects,
            most commonly the <i>default database object</i>, provided by the configuration, and
            dynamically instantiates these as required.</p>
        <p>The most common way of accessing the database is to use any of the <tt>NF_DB::connect()->queryXXX()</tt> methods
            - <tt>NF_DB::connect()</tt> always returns a cached instance of the default database, so there is little overhead in
            calling in this manner.</p>
        <p>Databases are always accessed through PHP's PDO layer, but since it really is just two interfaces 
            (<tt>NF_IDatabase</tt> and <tt>NF_IResult</tt>), there is nothing that stops you from writing database classes for
            any conceivable driver.</p>
        
        <h2>8.2 Running a query against NF_DB::connect()</h2>
        <p>The following different codes may be used to query the database. They are all functionally 
            equivalent:</p>
        <code>$db = NF_DB::connect();

$resultset = $db->query('select * from users');

while (($row = $resultset->fetch()) !== false)
    $rows[] = $row;
    
$resultset->close();</code>
        <p>...or...</p>
        <code>$db = NF_DB::connect();
        
$rows = $db->queryAsArray('select * from users');</code>
        <p>...or...</p>
        <code>$rows = NF_DB::connect()->queryAsArray('select * from users');</code>
        
        <h2>8.3 Different ways of using the database object</h2>
        <p>Whether you're using <tt>NF_DB::connect()</tt> directly, or an <tt>NF_IDatabase</tt> instance returned from it, these
            methods are all available:</p>
        <table>
            <tr>
                <th colspan="2">The NF_IDatabase methods</th>
            </tr>
            <tr>
                <td><tt>query($sql)</tt></td>
                <td>Returns an <tt>NF_IResult</tt> object containing the data from the query.</td>
            </tr>
            <tr>
                <td><tt>queryAsArray($sql)</tt></td>
                <td>Returns an array of records, each containing an associative array of
                    fields => values.</td>
            </tr>
            <tr>
                <td><tt>queryAsObjects($sql)</tt></td>
                <td>Returns an array of records, each containing a StdClass object with the database fields as variables.</td>
            </tr>
            <tr>
                <td><tt>querySingleValueArray($sql)</tt></td>
                <td>If you're only querying one column, you can use this function to return
                    a single array of all the values found in all the rows.</td>
            </tr>
            <tr>
                <td><tt>queryScalar($sql)</tt></td>
                <td>If you're only querying one data value, such as <tt>select count(*) from users</tt>,
                    you can use this function to return the first column of the first row directly
                    and discard all other data.</td>
            </tr>
            <tr>
                <td><tt>queryLookup($sql)</tt></td>
                <td>If you're querying two columns in a lookup-table fashion, such as <tt>select userid, username from users</tt>, 
                    this function will return a single, associative array of userid => username data.</td>
            </tr>
            <tr>
                <td><tt>execute($sql)</tt></td>
                <td>Executes the query without return any result set.</td>
            </tr>
            <tr>
                <td><tt>date($timestamp)</tt></td>
                <td>Takes a timestamp and formats it the way this database likes formatted dates.</td>
            </tr>
            <tr>
                <td><tt>escape($string)</tt></td>
                <td>Escapes a particular string the way this database likes to escape values.</td>
            </tr>
            <tr>
                <td><tt>lastInsertId()</tt></td>
                <td>Returns the ID of the last inserted record, in case of auto-generating keys.</td>
            </tr>
        </table>
        
        <h2>8.4 Escaping data</h2>
        <p>To prevent against SQL Injection, it is necessary to properly escape all data inserted into
            SQL queries. Since NF_DB is just a wrapper around the PDO layer, there are two ways of doing this.</p>

        <h3>8.4.1 Using escape()</h3>
        <p>The first way is to use the <tt>escape()</tt> call.</p>
        <code>echo NF_DB::escape('hello');
-> 'hello'

echo NF_DB::escape('"hello"');
-> '\"hello\"'</code>
        <p>Escape properly escapes data and provides the quotes surrounding it (note that mysql_real_escape only
            quotes data, it doesn't surround it with quotes, which is an important difference), thus making it
            safe for inclusion in an SQL query. For instance:</p>
        <code>public function executeView($username)
{
    $username = NF_DB::escape($username);
    NF_DB::connect()->queryAsObjects("select * from users where username=$username");
}</code>
        <p>...should now be safe, although there is a more secure way of doing this, described below.</p>
        <p>Note that there is no difference between running <tt>NF_DB::escape()</tt> and <tt>$database->escape()</tt>, as long
            as you're working with the default database. NF_DB automatically forwards the escape() call to
            the default database which then escapes the input.</p>

        <h3>8.4.2 Using parameters</h3>
        <p>Although there is a function, escape(), for properly escaping user data into SQL statements, you should
            rely on this as little as possible, and instead using parameters. Parameters can be inserted into the
            SQL query in the following manner:</p>
        <code>// Single value inserted
$db->queryAsArray('select * from users where join_date >= ?', $date);

// Multiple values inserted
$db->queryAsArray('select * from users where firstname=? and lastname=?', array('John', 'Smith'));</code>
        <p>Every question mark in the SQL query will automatically have an argument inserted, properly escaped and in order.
            If there's only one argument, you're fine just writing it directly after the SQL query. If there are more arguments
            than one, pass along an array of arguments as in the second example.</p>
        <p>The advantage with this method is that you never have to escape data manually - Nifty and PDO does that for you
            in a completely reliable way.</p>
        <p>All the query() and execute() functions can be escaped in this manner.</p>
        
        <h2>8.5 Transactions</h2>
        <p>There are rudimentary support for transactions in Nifty using the following statements.</p>
        <table>
            <tr>
                <th colspan="2">NF_IDatabase transaction support</th>
            </tr>
            <tr>
                <td><tt>begin()</tt></td>
                <td>Begin a new transaction.</td>
            </tr>
            <tr>
                <td><tt>commit()</tt></td>
                <td>Commits the transaction by writing it to disk.</td>
            </tr>
            <tr>
                <td><tt>rollback()</tt></td>
                <td>Aborts the transaction and causes a rollback of all changes.</td>
            </tr>
            <tr>
                <td><tt>transaction($callback)</tt></td>
                <td>Wraps a callback function in a transaction, committing it if everything went okay and rolling it
                    back if an exception is thrown. The exception is then rethrown for further handling.</td>
            </tr>
        </table>
        <p>Using <tt>transaction()</tt>, you can, for instance, write the following code:</p>
        <code>$db->transaction(function() use ($db) {
    $db->execute('really complex SQL query');
    $db->execute('another really complex SQL query');
});</code>
        <p>If an exception is thrown, the changes will automatically be rolled back. It is functionally equivalent to writing<p>
        <code>$db->begin();
try {
    $db->execute('really complex SQL query');
    $db->execute('another really complex SQL query');
    $db->commit();
}
catch(Exception $e) {
    $this->rollback();
    throw $e;
}</code>
        
        <h2>8.6 Utility functions</h2>
        <p>Since NF_DB usually handles a lot of data objects and data arrays, it was convenient to add a few utility functions
            to help with managing those objects efficiently.</p>
        <p>Note that these belong to NF_DB directly - they don't work on an instantiated NF_IDatabase.</p>    
        <table>
            <tr>
                <th colspan="2">Useful NF_DB methods</th>
            </tr>
            <tr>
                <td><tt>connect($ref)</tt></td>
                <td>Connect to a database specified in the configuration.</td>
            </tr>
            <tr>
                <td><tt>hash($objects, $field)</tt></td>
                <td>Return an array where the keys of the array correspond to the field value given by $object->$field.</td>
            </tr>
            <tr>
                <td><tt>group($objects, $field)</tt></td>
                <td>Return an array where objects with the same $object->$field are grouped together in subarrays.</td>
            </tr>
        </table>
        
    </body>
</html>
