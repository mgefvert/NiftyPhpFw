<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
        <title>Get Started with Nifty Framework</title>
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
        <h1>4. Requests and responses</h1>
        
        <p>When it comes to web pages, everything is about requests and responses. These are encapsulated
            in the global objects <tt>$Request</tt> and <tt>$Response</tt>.</p>
        
        <h2>4.1 Requests: The $Request object</h2>
        <p>The global object <tt>$Request</tt> encapsulates most of the functionality necessary to handle all
            information about the request. Any parameter given on the URL is accessible by typing 
            <tt>$Request-><i>parameter</i></tt>, whether the transaction was a GET or a POST.</p>
        <p class="security">Note that no filtering is applied in this way; caution is required 
            as <i>any</i> user input may be faulty or malicious.</p>
        <p>This is a brief summary of all the methods in <tt>$Request</tt>:<p>
        
        <table>
            <tr>
                <th colspan="2">The $Request object</th>
            </tr>
            <tr>
                <td><i>param</i></td>
                <td>Directly invoking the parameter name allows you to get or set an individual parameter from the URL.
                    For instance, the URL <tt>http://host/page?firstname=Joe&lastname=Smith</tt>, gives the two parameters
                    <tt>$Request->firstname</tt> and <tt>$Request->lastname</tt>. Hyphens (-) are translated into
                    underscores (_).</td>
            </tr>
            <tr>
                <td><tt>get($var)</tt></td>
                <td>Same thing as using the <i>param</i> way of accessing parameters, but through a method instead.</td>
            </tr>
            <tr>
                <td><tt>getNumeric($var, $default)</tt></td>
                <td>Forces a parameter to an integer value. If it can't be turned to an int, an exception is thrown.</td>
            </tr>
            <tr>
                <td><tt>getSafe($var)</tt></td>
                <td>Filters out any characeters not in the range A-Z, a-z, 0-9, hyphen (-) and underscore(_).</td>
            </tr>
            <tr>
                <td><tt>getList($roots)</tt></td>
                <td>Parses parameters in a given list format, e.g. name-1, phone-1, name-2, phone-2, into easy to
                    use arrays.</td>
            </tr>
            <tr>
                <td><tt>isAjax()</tt></td>
                <td>This function if the request is an Ajax request, by examining the <tt>X-Requested-With</tt>
                    parameter. Not absolutely fool-proof, but works with most Ajax frameworks.</td>
            </tr>
            <tr>
                <td><tt>isGet()</tt></td>
                <td>This function returns true if the request is a GET. GET calls should only be
                    used to access information, not modify, create or destroy information.</td>
            </tr>
            <tr>
                <td><tt>isPost()</tt></td>
                <td>This function return strue if the request is a POST. POST data should normally be used to 
                    submit forms and cause transactions.</td>
            </tr>
        </table>
        
        <h2>4.2 Mapping URL parameters to method parameters</h2>
        <p>Access to parameters in the query string or in the submitted form data can always be done through <tt>$Request</tt>. However,
            it's also possible to map them directly to method parameters. Any parameter can be automatically passed on to the method
            by naming it as a parameter in the method signature.</p>
        <p>For instance, consider the following request:</p>
        <code>http://mysite/index/submit?id=4330&firstname=John&lastname=Smith</code>
        <p>These parameters are, of course, available through <tt>$Request->id</tt>, <tt>$Request->firstname</tt> and <tt>$Request->lastname</tt>.
            But they can also be forwarded directly to the method by writing it this way:</p>
        <code>public function executeSubmit($id, $firstname, $lastname)
{</code>
        <p>This will require the presence of the parameters: If not, an exception will be thrown since it isn't a valid call.
            If you want to make parameters optional, simply assign them a default value:</p>
        <code>public function executeSubmit($id = null, $firstname = null, $lastname = null)
{</code>
        <p>This ensures that the method is callable even if the parameters are omitted in the URL.</p>
        <p>Please note that the URL could also have been written <tt>http://mysite/index/submit/4330?firstname=John&lastname=Smith</tt>, which
            would have been exactly the same thing.</p>

        <h2>4.3 Responding, and the $Response object</h2>
        <p>All responses to the user may be done through the global variable <tt>$Response</tt>. It is available
            to the system in the same fashion as <tt>$Request</tt>.</p>
        <p><tt>$Response</tt> contains a number of methods and variables to simplify different kind of responses, 
            but the most common variable is <tt>$Response->content</tt>, which is used to set output which will be 
            sent to the client upon finalization.</p>
        <p>The Response object is usually initialized from parameters found in <tt>settings.conf</tt>, such as what
            master template to use, what language and content-type to use, etc. It is possible to override this behavior
            by calling <tt>$Response->reset()</tt>, which clears the Response object, and then you're able to customize
            the output exactly as needed.</p>
        <p>This is a brief summary of the methods available in <tt>$Response</tt>:</p>
        <table>
            <tr>
                <th colspan="2">The $Response object</th>
            </tr>
            <tr>
                <td><i>element</i></td>
                <td>Any unrecognized variable will be stored as a parameter and forwarded to the
                    master template which is used for the site. It is therefore possible to render
                    different HTML output and place in other variables, depending on the needs.</td>
            </tr>
            <tr>
                <td><tt>content</tt></td>
                <td>Main text output to either send directly to the user, or embed as content into
                    the master template, if one is provided.</td>
            </tr>
            <tr>
                <td><tt>template</tt></td>
                <td>Reference to a master template. Usually set automatically by the configuration.</td>
            </tr>
            <tr>
                <td><tt>title</tt></td>
                <td>A specific title to embed into the master template. 1)</td>
            </tr>
            <tr>
                <td><tt>contentType</tt></td>
                <td>A specific content type to use. Useful for setting encoding, e.g. iso8859-1 or utf-8, for the result. 1)</td>
            </tr>
            <tr>
                <td><tt>requireCss($url)</tt></td>
                <td>Appends a specific CSS file to the array of CSS files for the application. Requires a 
                    <tt>&lt;@css&gt;</tt> tag in the header of the master template. 1)</td>
            </tr>
            <tr>
                <td><tt>requireJs($url)</tt></td>
                <td>Appends a specific JavaScript file to the array of JS files for the application. Requires a
                    <tt>&lt;@js&gt;</tt> tag in the header of the master template. 1)</td>
            </tr>
            <tr>
                <td><tt>send()</tt></td>
                <td>Format the entire response and send the result to the user. Always done
                    by <tt>index.php</tt> automatically.</td>
            </tr>
            <tr>
                <td><tt>redirect($url)</tt></td>
                <td>Send a "Location:" header to the user, redirecting to another
                    page. Does not end the request automatically, you must return yourself.</td>
            </tr>
            <tr>
                <td><tt>slowRedirect($url)</tt></td>
                <td>Sends a HTML result to the end user, containing META REFRESH tags and a script, that
                    will send the user along to another page. This eliminates the possibility where the
                    user sends a POST, is processed, is then redirected, and presses F5 - and the browser
                    tries to repost the result. This will always forward the user cleanly to a fresh URL
                    without any reposting. As with redirect(), does not end the request automatically, you must return yourself.</td>
            </tr>
            <tr>
                <td><tt>reset()</tt></td>
                <td>Clear all <tt>$Response</tt> data, especially if a master template was used. Nothing
                    further will be done upon page finalization - that is, if you don't provide
                    <tt>$Response</tt> with new data.</td>
            </tr>
            <tr>
                <td><tt>streamFile()</tt></td>
                <td>If there is a large file sent to the user, e.g. downloading files or similar,
                    streamFile() can be used to put less strain on server resources. It will read
                    chunks of data from the file and stream it to the user, without any PHP caching
                    or buffering mechanism involved.</td>
            </tr>
            <tr>
                <td><tt>sendFile()</tt></td>
                <td>In some cases, streamFile() doesn't apply, such as when you produce data in the controller,
                    but you still want to send it as a file to the user. This method allows you to do that,
                    and also setting the MIME type and file name.</td>
            </tr>
            <tr>
                <td><tt>directOutput()</tt></td>
                <td>Completely shuts down the <tt>$Response</tt> object and allows you to <tt>echo()</tt>
                    information directly. Also tries (with varying levels of success) to end any default buffering
                    active from PHP, so output will be immediately sent by Apache.</td>
            </tr>
        </table>
        <p><sup>1)</sup> If no master template is used, this field is quietly ignored.</p>
        
        <h2>4.4 A really simple example</h2>
        <p>The following simple class will display to the user whatever he provided in the "input" parameter:</p>
        <code>&lt;php

class Test extends NF_Page
{
    public function executeView($input = '')
    {
        global $Response;
        
        $Response->content = 'Hello! Your input was ' . html($input);
    }
}</code>
        <br>
        <p class="security">Please notice the use of the html() global function to escape the data, to prevent from 
            cross-site scripting attacks.</p>

        <h2>4.5 GETs, POSTs and AJAX calls</h2>
        <p>Nifty usually doesn't make a big distinction between GET calls and POST calls. It handles them the say way. You, however,
            as the programmer, should make that distinction by checking the methods <tt>$Request->isGet()</tt> and <tt>$Request->isPost()</tt>.
            If it's a POST, then isPost() will return true, and you can direct the flow of execution in a certain way. It's possible,
            for instance, to have the same code present a web page as well as update the database with postback data, simply by
            distinguishing between isGet() and isPost().</p>
        <p>AJAX calls are automatically handled by Nifty, and you can check if a call is an AJAX call by using <tt>isAjax()</tt>. This
            checks for the presence of a special HTTP header which most frameworks supply. When an AJAX call is processed, the master
            template is automatically discarded, so everything you put into <tt>$Response->content</tt> is sent back to the client
            without further processing. It is advisable to also set <tt>$Response->contentType</tt> to something appropriate.</p>
        <p>Please note that most AJAX calls are assumed to be using utf-8, so you may need to translate parameters. By forcing an
            encoding in the response contentType, you may use something else than utf-8.</tt>
        
        <h2>4.6 A detailed look at the flow of any request</h2>
        <p>When <tt>$Request->invoke()</tt> is called, the following things happen:</p>
        <p>(Please note, that in all these examples, case sensitivity is important, and PascalCasing
            is always applied - that is, the framework maps the command <tt>view-page</tt> to <tt>ViewPage</tt>, 
            and <tt>this-is-a-test</tt> to <tt>ThisIsATest</tt>.)</p>
        
        <h3>4.6.1 Main setup</h3>
        <p>First of all, <tt>init.php</tt> configures the system. All global classes are instantiated, and the configuration
            is loaded.</p>
        <p>Next, <tt>init.php</tt> checks to see if there is a class called <tt>Application</tt> in <tt>/app/classes/Application.php</tt> - 
            if there is, it calls the <tt>init()</tt> method. This provides an ability for the application to initialize
            per each request, if additional handling is required.</p>
        
        <h3>4.6.2 Page loading</h3>
        <p>Secondly, the call is forwarded to the correct page. The framework examines the URL and looks for
            corresponding classes and methods in <tt>/app/pages</tt>. The call <tt>/admin</tt> therefore tries to load 
            the <tt>Admin</tt> class from the <tt>/app/pages/Admin.php</tt> file.</p>
        <p>The following criteria is applied:</p>
        <ul>
            <li>The class loaded must be a descendant of <tt>NF_PageBase</tt> (typically <tt>NF_Page</tt> or <tt>NF_AuthPage</tt>).</li>
            <li>If the class descends from <tt>NF_Page</tt>, the call is always forwarded without further access checking.</li>
            <li>If the class descends from <tt>NF_AuthPage</tt>, then <tt>NF_AuthPage</tt> checks the <tt>$Session->uid</tt> parameter, to see if
                we have an authenticated session. Otherwise, an <tt>NF_EAccessDenied</tt> exception is thrown and the call
                is rejected. This means that we have an efficient method of automatically barring access to pages
                through an inheritance mechanism.</li>
        </ul>
        <p>When the page is loaded, the protected method <tt>init()</tt> is always called to give the page a change to initialize
            itself, should that be required. If you do provide an <tt>init()</tt> method, be sure to call <tt>parent::init()</tt> as well in this method.</p>
        
        <h3>4.6.3 Method calls</h3>
        <p>It then tries to forward the call to the correct method. It looks at the URL again, to see if it matches
            any method in the following pattern:</p>
        <ul>
            <li>The method is PascalCased and prepended with the term 'execute'. I.e., if the command
                is <tt>/page/view-page</tt>, then the system looks for a method called <tt>executeViewPage</tt>.</li>
            <li>If it is found, it examines the parameters of the method. If the method does not take any
                parameters, it is immediately called. If, however, parameters are required, the system looks
                at the request and tries to map URL parameters to method parameters. If it can't find the
                parameter on the URL (and no default value is given for it), the call will fail.</li>
            <li>If no method was found, it will search for a method called <tt>executeDefault()</tt> and call that one.</li>
            <li>If still no method was found, it will throw an <tt>NF_EPageNotFound</tt> exception.</li>
        </ul>
        <p>So, for instance, given a file <tt>/app/pages/TestPage.php</tt> that looks like this:</p>
        <code>&lt;?php

class TestPage extends NF_Page
{
    public function executeView()
    {
        ...
    }
    
    public function executeEdit($id, $data = '', $user = 0)
    {
        ...
    }
}</code>
        <p>...you may call it with, for instance, <tt>http://host/test-page</tt>, <tt>http://host/test-page/view</tt>, and 
            <tt>http://host/test-page/edit/1</tt>, but the call <tt>http://host/test-page/edit</tt> will fail, since 
            no ID is given. To fill in data for the other parameters, use e.g. <tt>http://host/test-page/edit/1?data=hello&user=5</tt>.</p>
        
        <h3>4.6.5 Finishing the page</h3>
        <p>The system then calls the <tt>finalize()</tt> method of the page, giving it a chance to clean up.</p>
        
        <h3>4.6.6 Finishing the application</h3>
        <p>The system then calls the <tt>$Application->finish()</tt> method, if it exists, to give the application a
            chance to do site-wide processing before the output is combined and sent to the user. This might be a good
            opportunity to load and process menu structures, and render additional HTML data (ad displays?).</p>
            
        <h3>4.6.7 Sending the response</h3>
        <p>As a last measure, <tt>$Response->send()</tt> is called, which looks in <tt>/app/settings.conf</tt> to see if there's any
            master template specified. If so, that master template is loaded (unless it's an AJAX call, in which case the master template
            is discarded), and <tt>$Response->content</tt> is pushed into
            it, along with any other data that might be needed. If no master template exists, <tt>$Response->content</tt> is
            simply pushed without further ado to the end user.</p>
        <p>It is important to note that <tt>$Response->content</tt> is only one possible option - it is by convention the
            variable used to feed HTML into the master layout; however, Pages can set any number of variables,
            each of which is available to the master template in a similar way. A Page can therefore render many
            different parts of a page simultaneously, if necessary, although this is seldom done.</p>
        
    </body>
</html>
