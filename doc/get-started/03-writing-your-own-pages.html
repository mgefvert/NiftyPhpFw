<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
        <title>Get Started with Nifty Framework</title>
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
        <h1>3. Writing your own pages</h1>
        
        <h2>3.1 A word on routing</h2>
        
        <p>Whenever a request is made to a web page, Nifty will intercept this and take over. This is the function of
            <tt>.htaccess</tt> and <tt>index.php</tt>. All calls will be mapped onto the correct class, method, and
            ID, if provided.</p>
        <p>The fundamental structure of a URL request is this:</p>
        <code>http://your.website.com/page[/page...][/method[/id]][?parameters]</code>
        <p>It breaks down into the following structure:</p>
        <table>
            <tr>
                <td><tt>page[/page...]</tt></td>
                <td>Basically, every call is mapped to a Page (or a controller - same thing, different terminology).
                    Pages can be called Index, Main, Customer, Customer_Info or just about anything - these are class names.
                    Any path delimiter (/) in the URL is transformed to an underscore, so the request for <tt>customer/info/picture</tt>
                    would be translated to a call to the class <tt>Customer_Info_Picture</tt>, which would be located in 
                    <tt>app/pages/Customer/Info/Picture.php</tt>. If there is no page requested (blank), the page <tt>Index</tt> is loaded
                    (<tt>app/pages/Index.php</tt>).</td>
            </tr>
            <tr>
                <td><tt>[/method]</tt></td>
                <td>When the page has been located, the system tries to figure out what method to call. If no method was
                    specified, the "view" method will be called. It's always prefixed by the word "execute", so in that case, it would be
                    <tt>executeView()</tt>; and <tt>/list</tt> maps to <tt>executeList()</tt>, and so on. There is also a special method called
                    <tt>executeDefault()</tt>, which can be used to provide default behavior if no other method is found.</td>
            </tr>
            <tr>
                <td><tt>[/id]</tt></td>
                <td>Optionally, an ID can be submitted along with the method. It's passed as the parameter <tt>$id</tt> to the function. It's
                    the same thing as passing <tt>?id=...</tt> as a parameter, but putting it in the base URL provides for a cleaner syntax.</td>
            </tr>
            <tr>
                <td><tt>[?parameters]</tt></td>
                <td>Any other parameters are parsed and passed along as function parameters to the function. The function can either
                    declare them explicitly (as in "<tt>public function executeView($id, $mode)</tt>") or access them through 
                    <tt>$Request.</tt></td>
            </tr>
        </table>
        <p>So, a small code example which would intercept the call <tt>http://host/customer/view/42</tt> might be:</p>
        <code>class Customer extends NF_Page 
{
    public function executeView($id = null) 
    {
        ...
    }
}</code>

        <h2>3.2 File naming</h2>
        
        <p>File naming is important, since the autoloader expects a certain format.</p>
        
        <p>In URL-to-class translation, slashes are replaced by underscores, and hyphens delimit words using PascalCasing.</p>
        
        <h3>3.2.1 Pages</h3>
        
        <p>All pages are stored in the <tt>app/pages</tt> folder.</p>
        <p>The underscore symbolizes a slash, so that any class with an underscore in it is expected to both lie in the appropriate
            subdirectory, and as the url it takes slashes instead of underscores. Let me illustrate:</p>
        <table>
            <thead>
                <tr>
                    <th>URL</th>
                    <th>Page class name</th>
                    <th>File location</th>
                </tr>
            </thead>
            <tr class="tt">
                <td>/</td>
                <td>Index</td>
                <td>app/pages/Index.php</td>
            </tr>
            <tr class="tt">
                <td>/customer/special-invoice</td>
                <td>Customer_SpecialInvoice</td>
                <td>app/pages/Customer/SpecialInvoice.php</td>
            </tr>
            <tr class="tt">
                <td>/inventory/parts/two-screws</td>
                <td>Inventory_Parts_TwoScrews</td>
                <td>app/pages/Inventory/Parts/TwoScrews.php</td>
            </tr>
        </table>
        
        <h3>3.2.2 Classes</h3>
        
        <p>All other classes are stored in the <tt>app/classes</tt> folder, and are using the same directory naming scheme.
            For instance, the class External_Import would be stored in the file <tt>app/classes/External/Import.php</tt>.</p>
            
        <p>It is common to call data classes - normal classes that map to database tables - <tt>Data_Customer</tt>, <tt>Data_InvoiceRow</tt> and so on.
            This way, it is easy to store them all in a folder called <tt>app/classes/Data</tt>.
        
        <h3>3.2.3 Templates</h3>
        
        <p>Templates are stored in the <tt>app/templates</tt> folder, and using a different file naming scheme, for historical
            reasons. Technically, there is nothing to prevent you from storing them in any way you want to, but if you want to
            use the <tt>NF_Template::loadDefault()</tt> and <tt>NF_Template::runDefault()</tt> methods, then you would do well
            to use the recommended layout.</p>
        <p>Templates are stored much the same way as classes - however, they use lowercase letters and hyphens are retained. Also,
            the class name part points to the directory, and the method is the file name. The extension is normally ".phtml", not
            because it makes the author happy, but it makes is self-evident what is a template and what is not.</p>
        <table>
            <tr>
                <th>URL (with method)</th>
                <th>Class name and method</th>
                <th>Template location</th>
            </tr>
            <tr class="tt">
                <td>/</td>
                <td>Index->executeView()</td>
                <td>app/templates/index/view.phtml</td>
            </tr>
            <tr class="tt">
                <td>/customer/invoice</td>
                <td>Customer->executeInvoice()</td>
                <td>app/templates/customer/invoice.phtml</td>
            </tr>
            <tr class="tt">
                <td>/inventory/two-screws/view</td>
                <td>Inventory_TwoScrews->executeView()</td>
                <td>app/templates/inventory/two-screws/view.phtml</td>
            </tr>
        </table>
        
        <h2>3.3 Your first page</h2>
        
        <p>Now we're ready to make your first page.</p>
        <p>Save the following file as <tt>app/pages/Index.php</tt>.</p>
        <code>class Index extends NF_Page
{
    public function executeView()
    {
        global $Response;
        
        $Response->content = NF_Template::runDefault('', array(
            'message' => 'Hello, world!'
        ));
    }
}</code>
        <p>That's the page controller. Now create this file and save it as <tt>app/pages/index/view.phtml</tt>.</p>
        <code>&lt;h1&gt;&lt;?= html($this->message) ?&gt;&lt;/h1&gt;</code>
        <p>Now point your web browser to the root of your site (<tt>http://localhost/</tt>), and you should see "Hello, world!" in big letters. You're done!</p>
        <p>What happened?</p>
        <ul>
            <li>The request was intercepted and routed it to <tt>index.php</tt>.</li>
            <li>Since no URL path was given, the system uses the default page <tt>Index</tt> and the default 
                method <tt>executeView</tt>.</li>
            <li>The class <tt>NF_Template</tt>, responsible for all templating, was told to run the default template for 
                this call (<tt>index/view.phtml</tt>) with the parameter "message" set to "Hello, world!".</li>
            <li>The template loaded, <tt>$this->message</tt> evaluated to "Hello, world!", and it was sent through the function 
                <tt>html()</tt>, which translates &amp; &lt; &gt; to &amp;amp; &amp;lt; &amp;gt; and so on. It's the recommended way of always
                escaping string output - to guard against CSS attacks. (It's simply a wrapper around <tt>htmlspecialchars()</tt> with the
                appropriate parameters.)</li>
            <li>The output from the template was sent to <tt>$Response->content</tt>. This loads the master template,
                <tt>/app/templates/main.phtml</tt> - which can be configured separately - and inserts the output into the body
                element (in exactly the same way as the <tt>view.phtml</tt> template operated.</li>
            <li>Everything is sent back to the user, and the request ends.</li>
        </ul>
        
    </body>
</html>
